<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.13.0"/><link as="script" rel="preload" href="/webpack-runtime-a954c712b2e41912cb0a.js"/><link as="script" rel="preload" href="/framework-f24c3fbb71f117e223ab.js"/><link as="script" rel="preload" href="/app-6f4e9f8380b291bdc18c.js"/><link as="script" rel="preload" href="/component---src-pages-mdx-slug-js-a5a08f9e6991bb967cf0.js"/><link as="fetch" rel="preload" href="/page-data/flex/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2744905544.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><script>(function() { try {
  var mode = localStorage.getItem('theme-ui-color-mode');
  if (!mode) return
  document.documentElement.classList.add('theme-ui-' + mode);
} catch (e) {} })();</script><div id="___gatsby"><style data-emotion="css-global ehhlky">html{color:var(--theme-ui-colors-text);background-color:var(--theme-ui-colors-background);}</style><style data-emotion="css-global 0"></style><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><h1 class="css-1avyp1d">flex</h1><p class="css-1avyp1d">今天来复习一下flex布局</p><p class="css-1avyp1d">上一个章节的居中布局，最后一种方法就是使用弹性盒子。</p><p class="css-1avyp1d">弹性盒子的基本性质：</p><p class="css-1avyp1d">1.flex的属性适用于父子，父的孙元素不适应；</p><p class="css-1avyp1d">2.flex-basis的计算法则有两个分支；</p><p class="css-1avyp1d">3.善用margin-auto</p><p class="css-1avyp1d">属性和作用:flex 可以控制容器的顺序，大小，分布，对齐；</p><p class="css-1avyp1d"><strong class="css-1avyp1d">顺序 </strong>order</p><p class="css-1avyp1d"><strong class="css-1avyp1d">大小 </strong>flex-basis</p><p class="css-1avyp1d"><strong class="css-1avyp1d">分布 </strong></p><p class="css-1avyp1d">主轴 justify-content <!-- -->[<!-- -->通过控制主轴方向上元素之外的剩余空间，来控制元素布局<!-- -->]</p><p class="css-1avyp1d">辅轴 align-content <!-- -->[<!-- -->作用于辅轴，效果类似于justify-content，但是对应的是多行元素，需要配合flex-wrap使用<!-- -->]</p><p class="css-1avyp1d"><strong class="css-1avyp1d">对齐</strong></p><p class="css-1avyp1d">align-item<!-- -->[<!-- -->作用于辅轴，通过控制元素对齐的方式来控制元素的布局，作用于对齐的”基线“<!-- -->]</p><p class="css-1avyp1d">align-self 对用于单个弹性容器</p><h3 class="css-1avyp1d">一、 主轴和辅轴</h3><p class="css-1avyp1d">主轴方向上的尺寸即 主尺寸；</p><p class="css-1avyp1d">1.通常情况下，如果设定大小，弹性容器内的项目 会自动收缩；即一行收缩到各个项目的最小值，恰好可以容纳自身内容为限。</p><h3 class="css-1avyp1d">二、 对齐和空间</h3><p class="css-1avyp1d">沿主轴方向的叫做 justification 排布</p><p class="css-1avyp1d">沿辅轴方向的叫做 alignment 对齐</p><ol class="css-1avyp1d"><li class="css-1avyp1d">justify-content 主轴排布</li></ol><pre class="css-1avyp1d"><code class="language-css css-1avyp1d">.container{
   justify-content:flex-start;//默认值
//center,flex-end,space-between,space-around
其实本质上就是通过划分父容器的剩余空间来实现排布
}
</code></pre><p class="css-1avyp1d">水平方向的margin:auto</p><hr class="css-1avyp1d"/><p class="css-1avyp1d">在张鑫旭的css世界中，我们讨论过一个元素的width是怎么”体现出来的“</p><p class="css-1avyp1d">我对于margin：auto;的理解类似于昆虫的”外骨骼“或者大气压，可能大气压比较贴合；</p><p class="css-1avyp1d"><a href="98vtkf0NEOKnJVN6Lc4D8-v_NgngA54PukTZPNhNraY.svg" class="css-1avyp1d">drawio</a></p><p class="css-1avyp1d">上图只是为了理解，当margin 为auto的时候，子元素的width 是怎么在父容器中体现的。</p><p class="css-1avyp1d">我们把外层容器看成大气圈，子元素【包含内部的content和padding】看成是内部的一个气球。</p><p class="css-1avyp1d">当margin为auto的时候，气球在容器内收到了均匀的压力，就体现他在大气压下的”大小“</p><hr class="css-1avyp1d"/><p class="css-1avyp1d">所以我们可以使用margin在主轴上实现一些布局：</p><pre class="css-1avyp1d"><code class="language-html css-1avyp1d">&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;
  &lt;div class=&quot;item self&quot;&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre><pre class="css-1avyp1d"><code class="language-css css-1avyp1d">.container{
  display:flex;
}
.item{
  width:50px;
  border:1px solid red;
}
.self{
  marigin-left:auto;
}
</code></pre><p class="css-1avyp1d"><img src="images/vbfJNkjn22gvPk3lX0_JjIZXKcvlm65QsSCsTFtO_qc.png" alt="image" class="css-1avyp1d"/></p><p class="css-1avyp1d">设置为margin:auto可以吃掉所有剩余空间，把4号项目推到右侧；</p><ol start="2" class="css-1avyp1d"><li class="css-1avyp1d">辅轴对齐</li></ol><p class="css-1avyp1d">在上个实例中我们在调试模式下，调高父元素.container元素的高度，会发现不管父容器有多高，里面的子元素总是填满的。</p><p class="css-1avyp1d">align-items</p><p class="css-1avyp1d">这个属性默认是stretch，放在<strong class="css-1avyp1d">父容器</strong>上用来调节子元素的对齐位置</p><pre class="css-1avyp1d"><code class="language-css css-1avyp1d">.container{
  slign-items:stretch;
//flex-end,flex-start,center
我觉得基本上就是控制 margin-top/bottom的值来实现的
//这么说其实比较不合适，因为对齐应该还是受到baseline 的影响，即文字和容器的基线。
//我们常常可以通过设置最大font-size 来实现基线的对齐
}
</code></pre><hr class="css-1avyp1d"/><p class="css-1avyp1d"><img src="images/e8o_xrCIRIJQv839FU5bN78QBrhw3vF6tYorM18W5v8.png" alt="image" class="css-1avyp1d"/></p><p class="css-1avyp1d"><img src="images/gUutM0sbhU_4oZ-GAP-NT-E8H2BVnT0yDQd1lieWbjo.png" alt="image" class="css-1avyp1d"/></p><p class="css-1avyp1d">&quot;容器的基线由较大活动项的基线决定，其他项自动与之对齐&quot;</p><hr class="css-1avyp1d"/><p class="css-1avyp1d">所以再上一个文档中，怎么实现居中布局的方法：flex布局</p><pre class="css-1avyp1d"><code class="language-html css-1avyp1d">&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;item&quot;&gt;等待被居中的元素&lt;/div&gt;
&lt;/div&gt;
</code></pre><pre class="css-1avyp1d"><code class="language-css css-1avyp1d">.container{//方法1
  display:flex;
  justify-content:center;
  align-items:center;
}
</code></pre><pre class="css-1avyp1d"><code class="language-css css-1avyp1d">.container{//方法2
  display:flex;
  margin:auto auto;
}

</code></pre><ol start="3" class="css-1avyp1d"><li class="css-1avyp1d">尺寸</li></ol><p class="css-1avyp1d">flex的可伸缩体现在三个属性上</p><p class="css-1avyp1d">flex-basis,flex-shrink,flex-grow</p><p class="css-1avyp1d">flex-basis 控制项目在 主轴方向上的，经过修正之前的，首选大小；</p><p class="css-1avyp1d">关键字为auto 时，这个项目可以从对应的属性（width/height）哪里获取主尺寸。</p><p class="css-1avyp1d">如果没有设置对应尺寸，那么该项目就根据其内容确定大小：【类似浮动元素的包裹性】</p><p class="css-1avyp1d">flex-grow:弹性系数，在父容器通过flex-basis设置了 首选大小值之后，如果还有剩余空间，该系数用来决策怎么处理。默认值是0，表示不再进行扩展；</p><p class="css-1avyp1d">flex-shrink:弹性系数，空加不够应该如何收缩。默认值是1，表示空间不够的时候，所有项目都会以自己的首选尺寸为基准等比例收缩</p><p class="css-1avyp1d">计算过程</p><p class="css-1avyp1d">1.检查flex-basis，确定家乡的主尺寸</p><p class="css-1avyp1d">2.确定实际的主尺寸，如果按照假想的主尺寸把各项排布好还有剩余空间，则根据flex-grow伸展；</p><p class="css-1avyp1d">如果空间不够，则根据flex-shrink收缩</p><p class="css-1avyp1d">计算公式：当空间多余时，根据各个项目配置的flex-grow 系数总和 和项目系数所占的比重进行伸展；</p><p class="css-1avyp1d">当空间不够的时候，单个项目的收缩为</p><p class="css-1avyp1d">一个项目需要收缩的值 = <!-- -->[<!-- -->总共需要收缩的数值<!-- -->]<!-- --> <!-- -->*<!-- -->(<em class="css-1avyp1d">（item &#x27;s width </em>flex-shrink）/(the sum of all (item&#x27;s width <!-- -->*<!-- --> flex-shrink)))</p></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/flex/";window.___webpackCompilationHash="a566ed497c199120cb68";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-db109019bff945921aa3.js"],"app":["/app-6f4e9f8380b291bdc18c.js"],"component---src-pages-404-js":["/component---src-pages-404-js-f982e21b29e5e7bc41b1.js"],"component---src-pages-index-js":["/component---src-pages-index-js-0d971b4e67647cedc86d.js"],"component---src-pages-mdx-slug-js":["/component---src-pages-mdx-slug-js-a5a08f9e6991bb967cf0.js"],"component---src-pages-tags-js":["/component---src-pages-tags-js-7d6d2b95196e0f4f9e65.js"],"component---src-templates-blogpost-js":["/component---src-templates-blogpost-js-210533e9a6800d233e4c.js"],"component---src-templates-tagposts-js":["/component---src-templates-tagposts-js-75dfe830fda71d3c5e5c.js"]};/*]]>*/</script><script src="/polyfill-db109019bff945921aa3.js" nomodule=""></script><script src="/component---src-pages-mdx-slug-js-a5a08f9e6991bb967cf0.js" async=""></script><script src="/app-6f4e9f8380b291bdc18c.js" async=""></script><script src="/framework-f24c3fbb71f117e223ab.js" async=""></script><script src="/webpack-runtime-a954c712b2e41912cb0a.js" async=""></script></body></html>