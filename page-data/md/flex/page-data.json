{
    "componentChunkName": "component---src-templates-blogpost-js",
    "path": "/md/flex/",
    "result": {"data":{"markdownRemark":{"html":"<h1>flex</h1>\n<p>今天来复习一下flex布局</p>\n<p>上一个章节的居中布局，最后一种方法就是使用弹性盒子。</p>\n<p>弹性盒子的基本性质：</p>\n<p>1.flex的属性适用于父子，父的孙元素不适应；</p>\n<p>2.flex-basis的计算法则有两个分支；</p>\n<p>3.善用margin-auto</p>\n<p>属性和作用:flex 可以控制容器的顺序，大小，分布，对齐；</p>\n<p>**顺序 **order</p>\n<p>**大小 **flex-basis</p>\n<p>**分布 **</p>\n<p>主轴 justify-content [通过控制主轴方向上元素之外的剩余空间，来控制元素布局]</p>\n<p>辅轴 align-content [作用于辅轴，效果类似于justify-content，但是对应的是多行元素，需要配合flex-wrap使用]</p>\n<p><strong>对齐</strong></p>\n<p>align-item[作用于辅轴，通过控制元素对齐的方式来控制元素的布局，作用于对齐的”基线“]</p>\n<p>align-self 对用于单个弹性容器</p>\n<h3>一、 主轴和辅轴</h3>\n<p>主轴方向上的尺寸即 主尺寸；</p>\n<p>1.通常情况下，如果设定大小，弹性容器内的项目 会自动收缩；即一行收缩到各个项目的最小值，恰好可以容纳自身内容为限。</p>\n<h3>二、 对齐和空间</h3>\n<p>沿主轴方向的叫做 justification 排布</p>\n<p>沿辅轴方向的叫做 alignment 对齐</p>\n<ol>\n<li>justify-content 主轴排布</li>\n</ol>\n<pre><code class=\"language-css\">.container{\n   justify-content:flex-start;//默认值\n//center,flex-end,space-between,space-around\n其实本质上就是通过划分父容器的剩余空间来实现排布\n}\n</code></pre>\n<p>水平方向的margin:auto</p>\n<hr>\n<p>在张鑫旭的css世界中，我们讨论过一个元素的width是怎么”体现出来的“</p>\n<p>我对于margin：auto;的理解类似于昆虫的”外骨骼“或者大气压，可能大气压比较贴合；</p>\n<p><a href=\"98vtkf0NEOKnJVN6Lc4D8-v_NgngA54PukTZPNhNraY.svg\">drawio</a></p>\n<p>上图只是为了理解，当margin 为auto的时候，子元素的width 是怎么在父容器中体现的。</p>\n<p>我们把外层容器看成大气圈，子元素【包含内部的content和padding】看成是内部的一个气球。</p>\n<p>当margin为auto的时候，气球在容器内收到了均匀的压力，就体现他在大气压下的”大小“</p>\n<hr>\n<p>所以我们可以使用margin在主轴上实现一些布局：</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"container\">\n  &#x3C;div class=\"item\">1&#x3C;/div>\n  &#x3C;div class=\"item\">2&#x3C;/div>\n  &#x3C;div class=\"item self\">3&#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-css\">.container{\n  display:flex;\n}\n.item{\n  width:50px;\n  border:1px solid red;\n}\n.self{\n  marigin-left:auto;\n}\n</code></pre>\n<p><img src=\"images/vbfJNkjn22gvPk3lX0_JjIZXKcvlm65QsSCsTFtO_qc.png\" alt=\"image\"></p>\n<p>设置为margin:auto可以吃掉所有剩余空间，把4号项目推到右侧；</p>\n<ol start=\"2\">\n<li>辅轴对齐</li>\n</ol>\n<p>在上个实例中我们在调试模式下，调高父元素.container元素的高度，会发现不管父容器有多高，里面的子元素总是填满的。</p>\n<p>align-items</p>\n<p>这个属性默认是stretch，放在<strong>父容器</strong>上用来调节子元素的对齐位置</p>\n<pre><code class=\"language-css\">.container{\n  slign-items:stretch;\n//flex-end,flex-start,center\n我觉得基本上就是控制 margin-top/bottom的值来实现的\n//这么说其实比较不合适，因为对齐应该还是受到baseline 的影响，即文字和容器的基线。\n//我们常常可以通过设置最大font-size 来实现基线的对齐\n}\n</code></pre>\n<hr>\n<p><img src=\"images/e8o_xrCIRIJQv839FU5bN78QBrhw3vF6tYorM18W5v8.png\" alt=\"image\"></p>\n<p><img src=\"images/gUutM0sbhU_4oZ-GAP-NT-E8H2BVnT0yDQd1lieWbjo.png\" alt=\"image\"></p>\n<p>\"容器的基线由较大活动项的基线决定，其他项自动与之对齐\"</p>\n<hr>\n<p>所以再上一个文档中，怎么实现居中布局的方法：flex布局</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"container\">\n   &#x3C;div class=\"item\">等待被居中的元素&#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-css\">.container{//方法1\n  display:flex;\n  justify-content:center;\n  align-items:center;\n}\n</code></pre>\n<pre><code class=\"language-css\">.container{//方法2\n  display:flex;\n  margin:auto auto;\n}\n\n</code></pre>\n<ol start=\"3\">\n<li>尺寸</li>\n</ol>\n<p>flex的可伸缩体现在三个属性上</p>\n<p>flex-basis,flex-shrink,flex-grow</p>\n<p>flex-basis 控制项目在 主轴方向上的，经过修正之前的，首选大小；</p>\n<p>关键字为auto 时，这个项目可以从对应的属性（width/height）哪里获取主尺寸。</p>\n<p>如果没有设置对应尺寸，那么该项目就根据其内容确定大小：【类似浮动元素的包裹性】</p>\n<p>flex-grow:弹性系数，在父容器通过flex-basis设置了 首选大小值之后，如果还有剩余空间，该系数用来决策怎么处理。默认值是0，表示不再进行扩展；</p>\n<p>flex-shrink:弹性系数，空加不够应该如何收缩。默认值是1，表示空间不够的时候，所有项目都会以自己的首选尺寸为基准等比例收缩</p>\n<p>计算过程</p>\n<p>1.检查flex-basis，确定家乡的主尺寸</p>\n<p>2.确定实际的主尺寸，如果按照假想的主尺寸把各项排布好还有剩余空间，则根据flex-grow伸展；</p>\n<p>如果空间不够，则根据flex-shrink收缩</p>\n<p>计算公式：当空间多余时，根据各个项目配置的flex-grow 系数总和 和项目系数所占的比重进行伸展；</p>\n<p>当空间不够的时候，单个项目的收缩为</p>\n<p>一个项目需要收缩的值 = [总共需要收缩的数值] *(*（item 's width *flex-shrink）/(the sum of all (item's width * flex-shrink)))</p>","frontmatter":{"title":"flex布局详解"}}},"pageContext":{"slug":"/flex/","previous":null,"next":{"fields":{"slug":"/test/"},"frontmatter":{"title":"测试专用"}}}},
    "staticQueryHashes": ["2744905544"]}